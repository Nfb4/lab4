<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>

  <body>
    <!-- <script src="lab4.js"></script> -->

    <script>
      // CSV of spend data, all seasons in one csv
      let spendPerClubPerSeason =
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/spend.csv";

      // multiple csvs of stats for each individual season
      let csvArr = [
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem10-11.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem11-12.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem12-13.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem13-14.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem14-15.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem15-16.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem16-17.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem17-18.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem18-19.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem19-20.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem20-21.csv",
      ];

      // Dictionary to store totals data for each club
      let cumulative = {};

      // Dictionary of dictionaries for each club in each season
      let seasons = {
        "20-21": {},
        "19-20": {},
        "18-19": {},
        "17-18": {},
        "16-17": {},
        "15-16": {},
        "14-15": {},
        "13-14": {},
        "12-13": {},
        "11-12": {},
        "10-11": {},
      };

      const processCsvEntrySpend = async function (csvLine) {
        // do stuff for that single csv
        let entryDict = {};

        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["spend"].slice(csvLine["spend"].length - 3) == "Th.") {
          spend =
            parseFloat(csvLine["spend"].slice(1, csvLine["spend"].length - 3)) *
            0.001;
        }
        // If there is no value set spend to 0
        else if (csvLine["spend"] == "") {
          spend = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          spend = parseFloat(
            csvLine["spend"].slice(1, csvLine["spend"].length - 1)
          );
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["inc"].slice(csvLine["inc"].length - 3) == "Th.") {
          inc =
            parseFloat(csvLine["inc"].slice(1, csvLine["inc"].length - 3)) *
            0.001;
        }
        // If there is no value set inc to 0
        else if (csvLine["inc"] == "") {
          inc = 0;
        }
        // Parse as int and remove '£' and 'M'
        else {
          inc = parseFloat(csvLine["inc"].slice(1, csvLine["inc"].length - 1));
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["net"].slice(csvLine["net"].length - 3) == "Th.") {
          net =
            parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 3)) *
            0.001;
        }
        // If there is no value set net to 0
        else if (csvLine["net"] == "") {
          net = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          net = parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 1));
        }

        entryDict["yr"] = csvLine["yr"];
        entryDict["team"] = csvLine["team"];
        entryDict["spend"] = spend;
        entryDict["inc"] = inc;
        entryDict["net"] = net;

        //return the data from the file
        return entryDict;
      };

      const dummyFunc = async function (csvPath) {
        const csvData = await d3.csv(csvPath);

        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySpend(csvData[i]);
          seasons[clubDict.yr][clubDict.team] = [
            clubDict.spend,
            clubDict.inc,
            clubDict.net,
          ];

          if (cumulative[clubDict.team] != undefined) {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0] + clubDict.spend,
              cumulative[clubDict.team][1] + clubDict.inc,
              cumulative[clubDict.team][0] +
                clubDict.spend -
                (cumulative[clubDict.team][1] + clubDict.inc),
            ];
          } else {
            // If it is undefined simply set the values
            cumulative[clubDict.team] = [
              clubDict.spend,
              clubDict.inc,
              clubDict.net,
            ];
          }
        }
      };

      const processCsvEntrySeason = async function (csvLine) {
        let entryDict = {};
        entryDict["team"] = csvLine["Squad"];

        entryDict["data"] = [
          parseFloat(csvLine["Rk"]),
          parseFloat(csvLine["W"]),
          parseFloat(csvLine["D"]),
          parseFloat(csvLine["L"]),
          parseFloat(csvLine["GF"]),
          parseFloat(csvLine["GA"]),
          parseFloat(csvLine["Pts"]),
        ];
        return entryDict;
      };

      const dummyFuncSeason = async function (csvPath) {
        let key = csvPath.slice(81, 86);
        const csvData = await d3.csv(csvPath);
        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySeason(csvData[i]);
          seasons[key][clubDict.team] = seasons[key][clubDict.team] = [
            seasons[key][clubDict.team][0],
            seasons[key][clubDict.team][1],
            seasons[key][clubDict.team][2],
            clubDict.data[0],
            clubDict.data[1],
            clubDict.data[2],
            clubDict.data[3],
            clubDict.data[4],
            clubDict.data[5],
            clubDict.data[6],
          ];
          if (cumulative[clubDict.team][3] != undefined) {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0],
              cumulative[clubDict.team][1],
              cumulative[clubDict.team][2],
              cumulative[clubDict.team][3] + clubDict[0],
              cumulative[clubDict.team][4] + clubDict[1],
              cumulative[clubDict.team][5] + clubDict[2],
              cumulative[clubDict.team][6] + clubDict[3],
              cumulative[clubDict.team][7] + clubDict[4],
              cumulative[clubDict.team][8] + clubDict[5],
              cumulative[clubDict.team][2] + clubDict[6],
            ];
          } else {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0],
              cumulative[clubDict.team][1],
              cumulative[clubDict.team][2],
              clubDict.data[0],
              clubDict.data[1],
              clubDict.data[2],
              clubDict.data[3],
              clubDict.data[4],
              clubDict.data[5],
              clubDict.data[6],
            ];
          }
        }
      };

      const graphing = async function (season, width, height) {
        var max = 0;
        for (const key in seasons[season]) {
          var clubSpend = seasons[season][key][0];
          if (clubSpend > max) {
            max = clubSpend;
          }
        }
        var y = d3
          .scaleBand()
          .range([0, height])
          .domain(Object.keys(seasons[season]))
          .padding(0.2);

        // Define the y scale so that the values are proportionate
        var x = d3.scaleLinear().domain([0, max]).range([0, width]);

        return [x, y];
      };

      // Function used to initilise the x and y axes on start
      const iniAxis = function (margin, width, height, svg, x, y) {
        // add a bottom x axis to the graph, class it as 'xBot'
        svg
          .append("g")
          .classed("xBot", true)
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add a top x axis to the graph, class it as 'xTop

        // Add a right Y axis class it as 'yLeft'
        svg
          .append("g")
          .classed("yLeft", true)
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));
      };

      const iniSVG = async function () {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 460 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3
          .select("body")
          .append("div")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );
        return [margin, width, height, svg];
      };

      const drawBars = function (season, x, y, svg, height) {
        // Iterate through the dataset and add rectangles for each item
        var mapped = Object.keys(seasons[season]).map((d) => {
          console.log();
          return {
            club: d,
            spend: seasons[season][d][0],
          };
        });

        var u = svg.selectAll("rect").data(mapped);

        u.enter()
          .append("rect")
          .attr("x", x(1))
          .attr("y", function (d) {
            return y(d.club);
          })
          .attr("height", y.bandwidth())
          .merge(u)
          .transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("width", function (d) {
            return x(d.spend);
          })
          .attr("fill", "red");

        u.transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("width", function (d) {
            return x(d.spend);
          });
      };

      const main = async function (spendPerClubPerSeason, csvArr) {
        // d3.select("body")
        //   .append("button")
        //   .text("change data")
        //   .on("click", async function () {
        //     svgArr[3].selectAll("g").remove()
        //     let scales = await graphing("11-12", svgArr[1], svgArr[2]);
        //     iniAxis(
        //       svgArr[0],
        //       svgArr[1],
        //       svgArr[2],
        //       svgArr[3],
        //       scales[0],
        //       scales[1]
        //     );
        //     drawBars("11-12", scales[0], scales[1], svgArr[3], svgArr[2]);
        //   });

        await dummyFunc(spendPerClubPerSeason);

        for (let i = 0; i < csvArr.length; i++) {
          await dummyFuncSeason(csvArr[i]);
        }
        let svgArr = await iniSVG();
        let scales = await graphing("10-11", svgArr[1], svgArr[2]);

        iniAxis(
          svgArr[0],
          svgArr[1],
          svgArr[2],
          svgArr[3],
          scales[0],
          scales[1]
        );
        for (let i = 0; i < csvArr.length; i++) {
          let key = csvArr[i].slice(81, 86);
          svgArr[3].selectAll("g").remove();
          let scales = await graphing(key, svgArr[1], svgArr[2]);
          iniAxis(
            svgArr[0],
            svgArr[1],
            svgArr[2],
            svgArr[3],
            scales[0],
            scales[1]
          );
          console.log(key, scales[0], scales[1], svgArr[3], svgArr[2])
          drawBars(key, scales[0], scales[1], svgArr[3], svgArr[2]);
        }
      };

      main(spendPerClubPerSeason, csvArr);
    </script>
  </body>
</html>
