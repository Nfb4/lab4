<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <style>
    .tick line {
      visibility: hidden;
    }
  </style>
  <body>
    <!-- <script src="lab4.js"></script> -->
    <!-- Initialize a select button -->
    <div class="radarChart"></div>

    <script src="radarChart.js"></script>
    <select id="start"></select>
    <select id="end"></select>
    <button id="barButton">Update</button>
    <div id="barchart"></div>
    <select id="xAxisButton"></select>
    <select id="yAxisButton"></select>
    <select id="timePeriod"></select>
    <div id="scatter"></div>
    <div id="circular"></div>

    
    <script>
      // CSV of spend data, all seasons in one csv
      let spendPerClubPerSeason =
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/spend.csv";

      // multiple csvs of stats for each individual season
      let csvArr = [
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem10-11.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem11-12.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem12-13.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem13-14.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem14-15.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem15-16.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem16-17.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem17-18.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem18-19.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem19-20.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem20-21.csv",
      ];

      // Dictionary to store totals data for each club
      let cumulative = {
        Arsenal: [0],
        Chelsea: [0],
        "Manchester Utd": [0],
        "Manchester City": [0],
        Liverpool: [0],
        Tottenham: [0],
      };

      // Dictionary of dictionaries for each club in each season
      let seasons = {
        "20-21": {},
        "19-20": {},
        "18-19": {},
        "17-18": {},
        "16-17": {},
        "15-16": {},
        "14-15": {},
        "13-14": {},
        "12-13": {},
        "11-12": {},
        "10-11": {},
      };

      const processCsvEntrySpend = async function (csvLine) {
        // do stuff for that single csv
        let entryDict = {};

        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["spend"].slice(csvLine["spend"].length - 3) == "Th.") {
          spend =
            parseFloat(csvLine["spend"].slice(1, csvLine["spend"].length - 3)) *
            0.001;
        }
        // If there is no value set spend to 0
        else if (csvLine["spend"] == "") {
          spend = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          spend = parseFloat(
            csvLine["spend"].slice(1, csvLine["spend"].length - 1)
          );
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["inc"].slice(csvLine["inc"].length - 3) == "Th.") {
          inc =
            parseFloat(csvLine["inc"].slice(2, csvLine["inc"].length - 3)) *
            0.001;
        }
        // If there is no value set inc to 0
        else if (csvLine["inc"] == "") {
          inc = 0;
        }
        // Parse as int and remove '£' and 'M'
        else {
          inc = parseFloat(csvLine["inc"].slice(2, csvLine["inc"].length - 1));
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["net"].slice(csvLine["net"].length - 3) == "Th.") {
          net =
            parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 3)) *
            0.001;
        }
        // If there is no value set net to 0
        else if (csvLine["net"] == "") {
          net = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          net = parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 1));
        }

        entryDict["yr"] = csvLine["yr"];
        entryDict["team"] = csvLine["team"];
        entryDict["spend"] = spend;
        entryDict["inc"] = inc;
        entryDict["net"] = net;

        //return the data from the file
        return entryDict;
      };

      const dummyFunc = async function (csvPath) {
        const csvData = await d3.csv(csvPath);

        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySpend(csvData[i]);
          seasons[clubDict.yr][clubDict.team] = [
            clubDict.spend,
            clubDict.inc,
            clubDict.net,
          ];
          try {
            if (cumulative[clubDict.team] != undefined) {
              if (cumulative[clubDict.team][0] > 0) {
                cumulative[clubDict.team] = [
                  cumulative[clubDict.team][0] + clubDict.spend,
                  cumulative[clubDict.team][1] + clubDict.inc,
                  cumulative[clubDict.team][0] +
                    clubDict.spend -
                    (cumulative[clubDict.team][1] + clubDict.inc),
                ];
              } else {
                cumulative[clubDict.team] = [
                  clubDict.spend,
                  clubDict.inc,
                  clubDict.net,
                ];
              }
            }
          } catch (err) {}
          }
          
        };

      const processCsvEntrySeason = async function (csvLine) {
        let entryDict = {};
        entryDict["team"] = csvLine["Squad"];

        entryDict["data"] = [
          parseFloat(csvLine["Rk"]),
          parseFloat(csvLine["W"]),
          parseFloat(csvLine["D"]),
          parseFloat(csvLine["L"]),
          parseFloat(csvLine["GF"]),
          parseFloat(csvLine["GA"]),
          parseFloat(csvLine["Pts"]),
          parseInt(csvLine["Attendance"]),
        ];
        return entryDict;
      };

      const dummyFuncSeason = async function (csvPath) {
        let key = csvPath.slice(68, 73);
        const csvData = await d3.csv(csvPath);
        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySeason(csvData[i]);
          seasons[key][clubDict.team] = seasons[key][clubDict.team] = [
            seasons[key][clubDict.team][0],
            seasons[key][clubDict.team][1],
            seasons[key][clubDict.team][2],
            clubDict.data[1],
            clubDict.data[2],
            clubDict.data[3],
            clubDict.data[4],
            clubDict.data[5],
            clubDict.data[6],
            clubDict.data[7],
          ];
          try {
            if (cumulative[clubDict.team] != undefined) {
              if (cumulative[clubDict.team][3] != undefined) {
                cumulative[clubDict.team] = [
                  cumulative[clubDict.team][0],
                  cumulative[clubDict.team][1],
                  cumulative[clubDict.team][2],
                  cumulative[clubDict.team][3] + clubDict.data[1],
                  cumulative[clubDict.team][4] + clubDict.data[2],
                  cumulative[clubDict.team][5] + clubDict.data[3],
                  cumulative[clubDict.team][6] + clubDict.data[4],
                  cumulative[clubDict.team][7] + clubDict.data[5],
                  cumulative[clubDict.team][8] + clubDict.data[6],
                ];
              } else {
                cumulative[clubDict.team] = [
                  cumulative[clubDict.team][0],
                  cumulative[clubDict.team][1],
                  cumulative[clubDict.team][2],
                  clubDict.data[1],
                  clubDict.data[2],
                  clubDict.data[3],
                  clubDict.data[4],
                  clubDict.data[5],
                  clubDict.data[6],
                ];
              }
            }
          } catch (err) {}
        }
      };

      const graphing = async function (totals, width, height) {
        var max = 0;
        for (const key in totals) {
          var clubSpend = totals[key][0];
          if (clubSpend > max) {
            max = clubSpend;
          }
        }
        var y = d3.scaleBand().domain(Object.keys(totals)).range([0, height]);

        // Define the y scale so that the values are proportionate
        var x = d3.scaleLinear().domain([0, max]).range([0, width]);

        return [x, y];
      };

      const scatterAxes = async function (season, xType, yType, width, height) {
        var maxX = 0;
        var maxY = 0;
        for (const key in seasons[season]) {
          var clubX = seasons[season][key][xType];
          var clubY = seasons[season][key][yType];
          if (clubX > maxX) {
            maxX = clubX;
          }
          if (clubY > maxY) {
            maxY = clubY;
          }
        }
        var y = d3
          .scaleLinear()
          .domain([0, maxY + 5])
          .range([height, 0]);

        // Define the y scale so that the values are proportionate
        var x = d3
          .scaleLinear()
          .domain([0, maxX + 5])
          .range([0, width]);

        return [x, y];
      };

      const circularAxes = async function (
        totals,
        width,
        height,
        innerRadius,
        outerRadius
      ) {
        var max1 = 0;
        var max2 = 0;
        for (const key in totals) {
          var clubSpend = totals[key][0];
          var clubInc = totals[key][1];
          if (clubSpend > max1) {
            max1 = clubSpend;
          }
          if (clubInc > max2) {
            max2 = clubInc;
          }
        }

        var x = d3
          .scaleBand()
          .range([0, 2 * Math.PI]) // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
          .align(0) // This does nothing
          .domain(Object.keys(totals)); // The domain of the X axis is the list of states.
        var y = d3
          .scaleRadial()
          .range([innerRadius, outerRadius]) // Domain will be define later.
          .domain([0, max1]); // Domain of Y is from 0 to the max seen in the data
        var ybis = d3
          .scaleRadial()
          .range([innerRadius, 5]) // Domain will be defined later.
          .domain([0, max2]);
        return [x, y, ybis];
      };

      // Function used to initilise the x and y axes on start
      const iniAxis = function (height, svg, x, y) {
        // add a bottom x axis to the graph, class it as 'xBot'
        svg
          .append("g")
          .classed("xBot", true)
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add a top x axis to the graph, class it as 'xTop

        // Add a right Y axis class it as 'yLeft'
        svg.append("g").classed("yLeft", true).call(d3.axisLeft(y));
      };

      const iniSVG = async function () {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3
          .select("#barchart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        return [margin, width, height, svg];
      };

      const iniSVGCircular = async function () {
        // set the dimensions and margins of the graph
        const margin = { top: 400, right: 0, bottom: 0, left: 300 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        const innerRadius = 90;
        const outerRadius = Math.min(width, height) / 2;

        // append the svg object to the body of the page
        var svg = d3
          .select("#circular")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        svg
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(0," + -300 + ")")
          .text("All time Spend (green) v All time Income (red)");

        return [margin, width, height, svg, innerRadius, outerRadius];
      };

      const iniSVGScatter = async function (season, seasonsArr) {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3
          .select("#scatter")
          .append("svg")
          .classed("scatterSVG", true)
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        const axisValues = [
          "Goals For",
          "Goals Against",
          "Wins",
          "Draws",
          "Loses",
          "Spend",
          "Incoming Money",
          "Points",
          "Attendance",
        ];

        // add the options to the button
        d3.select("#xAxisButton")
          .selectAll("myOptions")
          .data(axisValues)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

        // add the options to the button
        d3.select("#yAxisButton")
          .selectAll("myOptions")
          .data(axisValues)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

        d3.select("#timePeriod")
          .selectAll("myOptions")
          .data(seasonsArr)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

        return [margin, width, height, svg];
      };

      const drawBars = function (season, totals, x, y, svg, height, barsize) {
        // Iterate through the dataset and add rectangles for each item
        var mapped = Object.keys(totals).map((d) => {
          return {
            club: d,
            spend: totals[d][0],
          };
        });
        let adjustment = mapped.length / 4;
        var u = svg.selectAll("rect").data(mapped);

        u.enter()
          .append("rect")
          .attr("x", x(1))
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("height", barsize)
          .merge(u)
          .transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("width", function (d) {
            return x(d.spend);
          })
          .attr("fill", "#bfe3ab");

        u.transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("x", x(1))
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("width", function (d) {
            return x(d.spend);
          });

        u.exit().remove();
      };

      const updateBar = async function (totals, key, svgArr, barsize) {
        svgArr[3].selectAll("g").remove();

        let scales = await graphing(totals, svgArr[1], svgArr[2]);

        iniAxis(svgArr[2], svgArr[3], scales[0], scales[1]);

        drawBars(
          key,
          totals,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          barsize
        );
      };

      const drawCircle = function (
        totals,
        x,
        y,
        ybis,
        svg,
        height,
        width,
        innerRadius,
        outerRadius
      ) {
        var mapped = Object.keys(totals).map((d) => {
          return {
            club: d,
            spend: totals[d][0],
            inc: totals[d][1],
          };
        });

        svg
          .append("g")
          .selectAll("path")
          .data(mapped)
          .enter()
          .append("path")
          .attr("fill", "#69b3a2")
          .attr(
            "d",
            d3
              .arc() // imagine your doing a part of a donut plot
              .innerRadius(innerRadius)
              .outerRadius(function (d) {
                return y(d.spend);
              })
              .startAngle(function (d) {
                return x(d.club);
              })
              .endAngle(function (d) {
                return x(d.club) + x.bandwidth();
              })
              .padAngle(0.01)
              .padRadius(innerRadius)
          );

        svg
          .append("g")
          .selectAll("g")
          .data(mapped)
          .enter()
          .append("g")
          .attr("text-anchor", function (d) {
            return (x(d.club) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) <
              Math.PI
              ? "end"
              : "start";
          })
          .attr("transform", function (d) {
            return (
              "rotate(" +
              (((x(d.club) + x.bandwidth() / 2) * 180) / Math.PI - 90) +
              ")" +
              "translate(" +
              (y(d.spend) + 10) +
              ",0)"
            );
          })
          .append("text")
          .text(function (d) {
            return d.club;
          })
          .attr("transform", function (d) {
            return (x(d.club) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) <
              Math.PI
              ? "rotate(180)"
              : "rotate(0)";
          })
          .style("font-size", "11px")
          .attr("alignment-baseline", "middle");

        svg
          .append("g")
          .selectAll("path")
          .data(mapped)
          .enter()
          .append("path")
          .attr("fill", "red")
          .attr(
            "d",
            d3
              .arc() // imagine your doing a part of a donut plot
              .innerRadius(function (d) {
                return ybis(0);
              })
              .outerRadius(function (d) {
                return ybis(d.inc);
              })
              .startAngle(function (d) {
                return x(d.club);
              })
              .endAngle(function (d) {
                return x(d.club) + x.bandwidth();
              })
              .padAngle(0.01)
              .padRadius(innerRadius)
          );
      };

      const updateCircle = async function (totals, svgArr) {
        svgArr[3].selectAll("g").remove();

        let scales = await circularAxes(
          totals,
          svgArr[1],
          svgArr[2],
          svgArr[4],
          svgArr[5]
        );

        drawCircle(
          totals,
          scales[0],
          scales[1],
          scales[2],
          svgArr[3],
          svgArr[2],
          svgArr[1],
          svgArr[4],
          svgArr[5]
        );
      };

      const drawScatter = function (
        season,
        x,
        y,
        svg,
        height,
        scatterX,
        scatterY,
        icons
      ) {
        // Iterate through the dataset and add rectangles for each item
        var mapped = Object.keys(seasons[season]).map((d) => {
          console.log(seasons[season][d][scatterX]);
          return {
            club: d,
            xVal: seasons[season][d][scatterX],
            yVal: seasons[season][d][scatterY],
          };
        });
        svg.selectAll("image").remove();

        var u = svg.selectAll("image").data(mapped);

        u.enter()
          .append("image")
          .attr("xlink:href", function (d) {
            console.log(d);

            return icons[d.club];
          })
          .attr("x", function (d) {
            return x(d.xVal);
          })
          .attr("y", function (d) {
            return y(d.yVal);
          })
          .attr("width", 35)
          .attr("height", 35);
      };

      const updateScatter = async function (
        key,
        svgArr,
        scatterX,
        scatterY,
        icons
      ) {
        svgArr[3].selectAll("g").remove();

        let scales = await scatterAxes(
          key,
          scatterX,
          scatterY,
          svgArr[1],
          svgArr[2]
        );
        iniAxis(svgArr[2], svgArr[3], scales[0], scales[1]);
        drawScatter(
          key,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          scatterX,
          scatterY,
          icons
        );
      };

      const iniIcons = async function () {
        // Icons sourced from
        // https://iconarchive.com/show/english-football-club-icons-by-giannis-zographos.html
        let icons = {
          Arsenal:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Arsenal%20FC.ico",
          "Aston Villa":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Aston%20Villa.ico",
          "Birmingham City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Birmingham%20City.ico",
          Blackburn:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Blackburn%20Rovers.ico",
          Blackpool:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Blackpool%20FC.ico",
          Bolton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Bolton%20Wanderers.ico",
          Bournemouth:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Bournemouth.ico",
          Brighton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Brighton%20%26%20Hove%20Albion.ico",
          Burnley:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Burnley%20FC.ico",
          "Cardiff City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Cardiff%20City.ico",
          Chelsea:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Chelsea%20FC.ico",
          "Crystal Palace":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Crystal%20Palace.ico",
          Everton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Everton%20FC.ico",
          Fulham:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Fulham%20FC.ico",
          Huddersfield:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Huddersfield%20Town.ico",
          "Hull City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Hull%20City.ico",
          "Leeds United":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Leeds%20United.ico",
          "Leicester City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Leicester%20City.ico",
          Liverpool:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Liverpool%20FC.ico",
          "Manchester City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Manchester%20City.ico",
          "Manchester Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Manchester%20United.ico",
          Middlesbrough:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Middlesbrough%20FC.ico",
          "Newcastle Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Newcastle%20United.ico",
          "Norwich City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Norwich%20City.ico",
          QPR: "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Queens%20Park%20Rangers.ico",
          Reading:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Reading%20FC.ico",
          "Sheffield Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Sheffield%20United.ico",
          Southhampton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Southampton%20FC.ico",
          "Stoke City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Stoke%20City.ico",
          Sunderland:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Sunderland%20AFC.ico",
          "Swansea City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Swansea%20City.ico",
          Tottenham:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Tottenham%20Hotspur.ico",
          Watford:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Watford%20FC.ico",
          "West Brom":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/West%20Bromwich%20Albion.ico",
          "West Ham":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/West%20Ham%20United.ico",
          "Wigan Athletic":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Wigan%20Athletic.ico",
          Wolves:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Wolverhampton%20Wanderers.ico",
        };
        return icons;
      };

      const iniButtons = function (seasonsArr, seasonsArr2) {
        d3.select("#start")
          .selectAll("myOptions")
          .data(seasonsArr)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
        d3.select("#end")
          .selectAll("myOptions")
          .data(seasonsArr2)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
      };

      const iniButtonsSingle = function (seasonsArr2) {
        d3.select("#end")
          .selectAll("myOptions")
          .data(seasonsArr2)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
      };

      const iniBarChart = async function (
        svgArrBar,
        seasonKey1,
        seasonKey2,
        csvArr,
        totals,
        barsize
      ) {
        svgArrBar[3].selectAll("text").remove();

        svgArrBar[3]
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(" + svgArrBar[1] / 2 + ", 0)")
          .attr("text-anchor", "middle")
          .text(
            "Premier league spend from " + seasonKey1 + " to " + seasonKey2
          );

        let sleepVal = 0;
        for (let i = 0; i < csvArr.length; i++) {
          let key = csvArr[i].slice(68, 73);

          await dummyFuncSeason(csvArr[i]);
          for (let team in seasons[key]) {
            if (seasons[key][team][0] > 0) {
              if (totals[team] != undefined) {
                totals[team][0] = totals[team][0] + seasons[key][team][0];
              } else {
                totals[team] = [seasons[key][team][0], 0];
              }
            }
            if (seasons[key][team][1] > 0) {
              if (totals[team] != undefined) {
                totals[team][1] = totals[team][1] + seasons[key][team][1];
              } else {
                totals[team][1] = [0, seasons[key][team][1]];
              }
            }
          }

          await sleep(sleepVal);
          sleepVal = 0;
          svgArrBar[3]
            .selectAll("text")
            .text("Premier league spend from 10-11 to " + key);
          await updateBar(totals, key, svgArrBar, barsize);
        }
      };

      const iniBarChartUpdate = async function (
        svgArrBar,
        seasonKey1,
        seasonKey2,
        csvArr,
        barsize
      ) {
        totals = {};

        svgArrBar[3].selectAll("text").remove();

        svgArrBar[3]
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(" + svgArrBar[1] / 2 + ", 0)")
          .attr("text-anchor", "middle")
          .text(
            "Premier league spend from " + seasonKey1 + " to " + seasonKey2
          );

        let sleepVal = 300;
        for (let i = 0; i < csvArr.length; i++) {
          let key = csvArr[i].slice(68, 73);

          await dummyFuncSeason(csvArr[i]);
          for (let team in seasons[key]) {
            if (seasons[key][team][0] > 0) {
              if (totals[team] != undefined) {
                totals[team][0] = totals[team][0] + seasons[key][team][0];
              } else {
                totals[team] = [seasons[key][team][0], 0];
              }
            }
            if (seasons[key][team][1] > 0) {
              if (totals[team] != undefined) {
                totals[team][1] = totals[team][1] + seasons[key][team][1];
              } else {
                totals[team][1] = [0, seasons[key][team][1]];
              }
            }
          }

          await sleep(sleepVal);
          sleepVal = 1500;
          svgArrBar[3]
            .selectAll("text")
            .text("Premier league spend from " + seasonKey1 + " to " + key);
          await updateBar(totals, key, svgArrBar, barsize);
        }
      };

      const radar = function () {
        /* Radar chart design created by Nadieh Bremer - VisualCinnamon.com */

        //////////////////////////////////////////////////////////////
        //////////////////////// Set-Up //////////////////////////////
        //////////////////////////////////////////////////////////////

        var margin = { top: 100, right: 100, bottom: 100, left: 100 },
          width =
            Math.min(700, window.innerWidth - 10) - margin.left - margin.right,
          height = Math.min(
            width,
            window.innerHeight - margin.top - margin.bottom - 20
          );

        //////////////////////////////////////////////////////////////
        //////////////////// Draw the Chart //////////////////////////
        //////////////////////////////////////////////////////////////

        var color = d3.scaleOrdinal().range(["#5bc8ef", "#5b60ef", "#b2c9c9", "#f31e56", "#f74018", "#56da41" ]);

        var radarChartOptions = {
          w: width,
          h: height,
          margin: margin,
          maxValue: 0.5,
          levels: 5,
          roundStrokes: true,
          color: color,
        };
        let key = '16-17';
        let big6Key = ['Arsenal', 'Chelsea', 'Manchester Utd', 'Manchester City', 'Liverpool', 'Tottenham'];
        let data = [];

        for(let i=0; i<big6Key.length;i++){
          data[big6Key[i]] = seasons[key][big6Key[i]]
        }

        //Call function to draw the Radar chart
        RadarChart(".radarChart", data, radarChartOptions);
      };

      const main = async function (spendPerClubPerSeason, csvArr) {
        let axisDict = {
          Spend: 0,
          "Incoming Money": 1,
          Wins: 3,
          Draws: 4,
          Loses: 5,
          "Goals For": 6,
          "Goals Against": 7,
          Points: 8,
          Attendance: 9,
        };

        const seasonsArr = [
          "10-11",
          "11-12",
          "12-13",
          "13-14",
          "14-15",
          "15-16",
          "16-17",
          "17-18",
          "18-19",
          "19-20",
          "20-21",
        ];

        let barsize = 10;

        let totals = {};

        let icons = await iniIcons();

        let seasonKey = csvArr[0].slice(68, 73);
        let scatterX = axisDict["Goals For"];
        let scatterY = axisDict["Goals For"];

        let seasonsArr2 = seasonsArr.slice(1);

        iniButtons(seasonsArr, seasonsArr2);

        await dummyFunc(spendPerClubPerSeason);

        let svgArrScatter = await iniSVGScatter(seasonKey, seasonsArr);

        let svgArrBar = await iniSVG();

        await iniBarChart(svgArrBar, "10-11", "20-21", csvArr, totals, barsize);

        await updateScatter(
          seasonKey,
          svgArrScatter,
          scatterX,
          scatterY,
          icons
        );

        d3.select("#timePeriod").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select(this).property("value");
          const option2 = d3.select("#xAxisButton").property("value");
          const option3 = d3.select("#yAxisButton").property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });

        d3.select("#yAxisButton").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select("#timePeriod").property("value");
          const option2 = d3.select("#xAxisButton").property("value");
          const option3 = d3.select(this).property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });

        d3.select("#xAxisButton").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select("#timePeriod").property("value");
          const option2 = d3.select(this).property("value");
          const option3 = d3.select("#yAxisButton").property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });

        d3.select("#start").on("change", function (event, d) {
          // recover the option that has been chosen
          const option = d3.select(this).property("value");

          let index = seasonsArr.findIndex((season) => season === option);

          removeOptions(document.getElementById("end"));
          iniButtonsSingle(seasonsArr.slice(index));
        });

        d3.select("#barButton").on("click", function (event, d) {
          const start = d3.select("#start").property("value");
          const end = d3.select("#end").property("value");
          let indexStart = seasonsArr.findIndex((season) => season === start);
          let indexEnd = seasonsArr.findIndex((season) => season === end);
          iniBarChartUpdate(
            svgArrBar,
            start,
            end,
            csvArr.slice(indexStart, indexEnd + 1),
            barsize
          );
          removeOptions(document.getElementById("start"));
          removeOptions(document.getElementById("end"));
          iniButtons(seasonsArr, seasonsArr.slice(indexEnd));
        });

        let svgArrCircular = await iniSVGCircular();
        await updateCircle(totals, svgArrCircular);

        radar();
      };
      function removeOptions(selectElement) {
        var i,
          L = selectElement.options.length - 1;
        for (i = L; i >= 0; i--) {
          selectElement.remove(i);
        }
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      main(spendPerClubPerSeason, csvArr);
    </script>
  </body>
</html>
