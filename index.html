<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <style>
    .tick line {
      visibility: hidden;
    }
  </style>
  <body>
    <!-- <script src="lab4.js"></script> -->
    <!-- Initialise 2 select buttons, one for the start year of the graph, one for the end year, also initilise an enter button to reload the graph
    along with a div for the bar chart -->
  
    <select id="start"></select>
    <select id="end"></select>
    <button id="barButton">Update</button>
    <div id="barchart"></div>
    <!--Div to hold the select buttons to choose the x and y axes for the graph and the season and another div for the scatter itself-->
    <div id="buttons">
      <select id="xAxisButton"></select>
      <select id="yAxisButton"></select>
      <select id="timePeriod"></select>
      Click a team crest to load the radar chart with that teams current season
    </div>
    <!-- Div for the scatter graph-->
    <div id="scatter"></div>

    <div class="radarChart"></div>
    <!-- Div for the circular bar chart-->
    <div id="circular"></div>
    <script>
      // CSV of spend data, all seasons in one csv
      // Data taken from: https://www.transfermarkt.co.uk/premier-league/einnahmenausgaben/wettbewerb/GB1
      let spendPerClubPerSeason =
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/spend.csv";

      // multiple csvs of stats for each individual season
      // Taken from: https://fbref.com/en/
      let csvArr = [
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem10-11.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem11-12.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem12-13.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem13-14.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem14-15.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem15-16.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem16-17.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem17-18.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem18-19.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem19-20.csv",
        "https://raw.githubusercontent.com/Nfb4/lab4/master/csvs/seasons/prem20-21.csv",
      ];

      // Dictionary of dictionaries for each club in each season
      let seasons = {
        "20-21": {},
        "19-20": {},
        "18-19": {},
        "17-18": {},
        "16-17": {},
        "15-16": {},
        "14-15": {},
        "13-14": {},
        "12-13": {},
        "11-12": {},
        "10-11": {},
      };

      const processCsvEntrySpend = async function (csvLine) {
        // Dictionary to store data for this single line of the csv
        let entryDict = {};

        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["spend"].slice(csvLine["spend"].length - 3) == "Th.") {
          spend =
            parseFloat(csvLine["spend"].slice(1, csvLine["spend"].length - 3)) *
            0.001;
        }
        // If there is no value set spend to 0
        else if (csvLine["spend"] == "") {
          spend = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          spend = parseFloat(
            csvLine["spend"].slice(1, csvLine["spend"].length - 1)
          );
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["inc"].slice(csvLine["inc"].length - 3) == "Th.") {
          inc =
            parseFloat(csvLine["inc"].slice(2, csvLine["inc"].length - 3)) *
            0.001;
        }
        // If there is no value set inc to 0
        else if (csvLine["inc"] == "") {
          inc = 0;
        }
        // Parse as int and remove '£' and 'M'
        else {
          inc = parseFloat(csvLine["inc"].slice(2, csvLine["inc"].length - 1));
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["net"].slice(csvLine["net"].length - 3) == "Th.") {
          net =
            parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 3)) *
            0.001;
        }
        // If there is no value set net to 0
        else if (csvLine["net"] == "") {
          net = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          net = parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 1));
        }
        // Add the values to the dictionary, now that the correct values have been ensured
        entryDict["yr"] = csvLine["yr"];
        entryDict["team"] = csvLine["team"];
        entryDict["spend"] = spend;
        entryDict["inc"] = inc;
        entryDict["net"] = net;

        //return the data from the file
        return entryDict;
      };

      const dummyFunc = async function (csvPath) {
        // Load the csv file
        const csvData = await d3.csv(csvPath);

        for (i = 0; i < csvData.length; i++) {
          // Call the processing helper function
          let clubDict = await processCsvEntrySpend(csvData[i]);
          // Add the returned ddata from the helper function to the appropriate club for the appropriate season
          seasons[clubDict.yr][clubDict.team] = [
            clubDict.spend,
            clubDict.inc,
            clubDict.net,
          ];

        }
      };

      const processCsvEntrySeason = async function (csvLine) {
        // Create a dictionary to store this lines data, parse all as float so that it can be plotted
        let entryDict = {};
        entryDict["team"] = csvLine["Squad"];

        entryDict["data"] = [
          parseFloat(csvLine["Rk"]),
          parseFloat(csvLine["W"]),
          parseFloat(csvLine["D"]),
          parseFloat(csvLine["L"]),
          parseFloat(csvLine["GF"]),
          parseFloat(csvLine["GA"]),
          parseFloat(csvLine["Pts"]),
          parseInt(csvLine["Attendance"]),
        ];
        return entryDict;
      };

      const dummyFuncSeason = async function (csvPath) {
        // Get the season key from the csvfiles string, the end contains the appropriate chars
        let key = csvPath.slice(68, 73);
        // load the csv file
        const csvData = await d3.csv(csvPath);
        // for each line in the csv file, call the helper function
        // then add the newly returned data to the apprpriate clubb and season, 
        // while maintaining the data from the spend function
        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySeason(csvData[i]);
          seasons[key][clubDict.team] = seasons[key][clubDict.team] = [
            seasons[key][clubDict.team][0],
            seasons[key][clubDict.team][1],
            seasons[key][clubDict.team][2],
            clubDict.data[1],
            clubDict.data[2],
            clubDict.data[3],
            clubDict.data[4],
            clubDict.data[5],
            clubDict.data[6],
            clubDict.data[7],
          ];
        }
      };

      const graphing = async function (totals, width, height) {
        // Find the max spend, as that is the field being graphed
        // This is used instead of the d3 function as due to the way data is stored 
        // it was easier to access data in this way
        var max = 0;
        for (const key in totals) {
          var clubSpend = totals[key][0];
          if (clubSpend > max) {
            max = clubSpend;
          }
        }
        // Set the y access to be on the domain of the club names
        // heigh of the svg is the upper limit
        var y = d3.scaleBand().domain(Object.keys(totals)).range([0, height]);

        // The x axes is reach to the highest spend value and span the width of the svg
        var x = d3.scaleLinear().domain([0, max]).range([0, width]);

        return [x, y];
      };

      const scatterAxes = async function (season, xType, yType, width, height) {
        // Find the maxes for both values to set each axis,
        // again this is used rather than the d3 function as it was easier to access data this way
        var maxX = 0;
        var maxY = 0;
        for (const key in seasons[season]) {
          var clubX = seasons[season][key][xType];
          var clubY = seasons[season][key][yType];
          if (clubX > maxX) {
            maxX = clubX;
          }
          if (clubY > maxY) {
            maxY = clubY;
          }
        }
        // Set up the axis scales, the domains each have 5 added to them so that the team with the highest value for a 
        // field is not at the absolute edge of a graph and has some space for aesthetic purposes
        var y = d3
          .scaleLinear()
          .domain([0, maxY + 5])
          .range([height, 0]);

        // Define the y scale so that the values are proportionate
        var x = d3
          .scaleLinear()
          .domain([0, maxX + 5])
          .range([0, width]);

        return [x, y];
      };

      const circularAxes = async function (
        totals,
        width,
        height,
        innerRadius,
        outerRadius
      ) {
        // as essentially two bar charts are being plotted in the one graph a max must be found for each bar
        var max1 = 0;
        var max2 = 0;
        // Find the max spend and the max income to limit the graphs
        for (const key in totals) {
          var clubSpend = totals[key][0];
          var clubInc = totals[key][1];
          if (clubSpend > max1) {
            max1 = clubSpend;
          }
          if (clubInc > max2) {
            max2 = clubInc;
          }
        }

        var x = d3
          .scaleBand()
          .range([0, 2 * Math.PI]) // X axis goes from 0 to 2pi = all around the circle. If I stop at 1Pi, it will be around a half circle
          .align(0) // This does nothing
          .domain(Object.keys(totals)); // The domain of the X axis is the list of clubs.
        var y = d3
          .scaleRadial()
          .range([innerRadius, outerRadius])
          .domain([0, max1]); // Domain of Y is from 0 to the max seen in the data
        var ybis = d3
          .scaleRadial()
          .range([innerRadius, 5])
          .domain([0, max2]);
        return [x, y, ybis];
      };

      // Function used to initilise the x and y axes on start
      const iniAxis = function (height, svg, x, y) {
        // add a bottom x axis to the graph, class it as 'xBot'
        svg
          .append("g")
          .classed("xBot", true)
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add a top x axis to the graph, class it as 'xTop

        // Add a right Y axis class it as 'yLeft'
        svg.append("g").classed("yLeft", true).call(d3.axisLeft(y));
      };

      const iniSVG = async function () {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // append the svg object to the barchart div
        var svg = d3
          .select("#barchart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        return [margin, width, height, svg];
      };

      const iniSVGCircular = async function () {
        // set the dimensions and margins of the graph
        const margin = { top: 400, right: 0, bottom: 0, left: 300 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // Set the inner and outer radius that will be used for drawin the circles
        const innerRadius = 90;
        const outerRadius = Math.min(width, height) / 2;

        // append the svg object to the body of the page
        var svg = d3
          .select("#circular")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );
        
        svg
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(0," + -300 + ")")
          .text("All time Spend (green) v All time Income (red)");

        return [margin, width, height, svg, innerRadius, outerRadius];
      };

      const iniSVGScatter = async function (season, seasonsArr) {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3
          .select("#scatter")
          .append("svg")
          .classed("scatterSVG", true)
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        // The different options for the axis, these are loaded by the select buttons to allow for the selection of the axis 
        const axisValues = [
          "Goals For",
          "Goals Against",
          "Wins",
          "Draws",
          "Loses",
          "Spend",
          "Incoming Money",
          "Points",
          "Attendance",
        ];

        // add the options to the button
        d3.select("#xAxisButton")
          .selectAll("myOptions")
          .data(axisValues)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

        // add the options to the button
        d3.select("#yAxisButton")
          .selectAll("myOptions")
          .data(axisValues)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

          // Choice of seasons
        d3.select("#timePeriod")
          .selectAll("myOptions")
          .data(seasonsArr)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button

        return [margin, width, height, svg];
      };

      const drawBars = function (season, totals, x, y, svg, height, barsize) {
        // Iterate through each item in the dictioanry, add the club and spend values to a map
        var mapped = Object.keys(totals).map((d) => {
          return {
            club: d,
            spend: totals[d][0],
          };
        });
        // Adjustment value as the y values for the bars don't match properly with the labels
        let adjustment = mapped.length / 4;
        var u = svg.selectAll("rect").data(mapped);

        // For each item in the map add a rectangle
        u.enter()
          .append("rect")
          .attr("x", x(1)) // x(1) is used so that the bar does not start directly on the line
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("height", barsize)
          .merge(u)
          .transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("width", function (d) {
            return x(d.spend);
          })
          .attr("fill", "#bfe3ab");

        u.transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("x", x(0))
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("width", function (d) {
            return x(d.spend);
          });
          // remove when less bars entries are used, i.e when transitioning from full data to a select few seasons
        u.exit().remove();
      };

      const updateBar = async function (totals, key, svgArr, barsize) {
        // remove the axes that exist, then readd with new values for maxes and clubs
        svgArr[3].selectAll("g").remove();

        let scales = await graphing(totals, svgArr[1], svgArr[2]);

        iniAxis(svgArr[2], svgArr[3], scales[0], scales[1]);
        // draw bars again now that data is updated
        drawBars(
          key,
          totals,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          barsize
        );
      };

      const drawCircle = function (
        totals,
        x,
        y,
        ybis,
        svg,
        height,
        width,
        innerRadius,
        outerRadius
      ) {
        // Take the club, spend and income from the totals dictionary and turn it to a map
        var mapped = Object.keys(totals).map((d) => {
          return {
            club: d,
            spend: totals[d][0],
            inc: totals[d][1],
          };
        });
        // Add paths for each spend item, using the first y scale
        svg
          .append("g")
          .selectAll("path")
          .data(mapped)
          .enter()
          .append("path")
          .attr("fill", "#69b3a2")
          .attr(
            "d",
            d3
              .arc() 
              .innerRadius(innerRadius)
              .outerRadius(function (d) {
                return y(d.spend);
              })
              .startAngle(function (d) {
                return x(d.club);
              })
              .endAngle(function (d) {
                return x(d.club) + x.bandwidth();
              })
              .padAngle(0.01)
              .padRadius(innerRadius)
          );
        // Add text for each club in the data set
        svg
          .append("g")
          .selectAll("g")
          .data(mapped)
          .enter()
          .append("g")
          .attr("text-anchor", function (d) {
            return (x(d.club) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) <
              Math.PI
              ? "end"
              : "start";
          })
          .attr("transform", function (d) {
            return (
              "rotate(" +
              (((x(d.club) + x.bandwidth() / 2) * 180) / Math.PI - 90) +
              ")" +
              "translate(" +
              (y(d.spend) + 10) +
              ",0)"
            );
          })
          .append("text")
          .text(function (d) {
            return d.club;
          })
          .attr("transform", function (d) {
            return (x(d.club) + x.bandwidth() / 2 + Math.PI) % (2 * Math.PI) <
              Math.PI
              ? "rotate(180)"
              : "rotate(0)";
          })
          .style("font-size", "11px")
          .attr("alignment-baseline", "middle");

        // add a path item for each income item, using the second y scale
        svg
          .append("g")
          .selectAll("path")
          .data(mapped)
          .enter()
          .append("path")
          .attr("fill", "red")
          .attr(
            "d",
            d3
              .arc() // imagine your doing a part of a donut plot
              .innerRadius(function (d) {
                return ybis(0);
              })
              .outerRadius(function (d) {
                return ybis(d.inc);
              })
              .startAngle(function (d) {
                return x(d.club);
              })
              .endAngle(function (d) {
                return x(d.club) + x.bandwidth();
              })
              .padAngle(0.01)
              .padRadius(innerRadius)
          );
      };

      const updateCircle = async function (totals, svgArr) {
        // Remove the axes
        svgArr[3].selectAll("g").remove();

        // re-create the ciruclar axes
        let scales = await circularAxes(
          totals,
          svgArr[1],
          svgArr[2],
          svgArr[4],
          svgArr[5]
        );
        // update the 'bars'
        drawCircle(
          totals,
          scales[0],
          scales[1],
          scales[2],
          svgArr[3],
          svgArr[2],
          svgArr[1],
          svgArr[4],
          svgArr[5]
        );
      };

      const drawScatter = function (
        season,
        x,
        y,
        svg,
        height,
        scatterX,
        scatterY,
        icons
      ) {
        // for each of the selected axes, iterate through the selected season of data and create a map
        var mapped = Object.keys(seasons[season]).map((d) => {
          return {
            club: d,
            xVal: seasons[season][d][scatterX],
            yVal: seasons[season][d][scatterY],
          };
        });
        // remove the existing images
        svg.selectAll("image").remove();

        // Create an image item for each entry in the map
        var u = svg.selectAll("image").data(mapped);

        u.enter()
          .append("image")
          .attr("xlink:href", function (d) {
            // Take the image link from the icons dictionary based on the entries club
            return icons[d.club];
          })
          .attr("x", function (d) {
            return x(d.xVal);
          })
          .attr("y", function (d) {
            return y(d.yVal);
          })
          .attr("width", 35)
          .attr("height", 35)
          .on("click", function (d) {
            // when clicking on a club crest load a radar chart for that club in the current season
            // Get the season data for the season in the select button, and get the key from the href value
            // in the icons dictionary
            let data2 =
              seasons[d3.select("#timePeriod").property("value")][
                getKeyByValue(icons, d.target.href.baseVal)
              ];
              // call radar chart with the respective season data, season and club
            RadarChart(
              ".radarChart",
              data2,
              d3.select("#timePeriod").property("value"),
              getKeyByValue(icons, d.target.href.baseVal)
            );
          });
      };
      // take an object and a value, return the first key for that value in the object
      function getKeyByValue(object, value) {
        return Object.keys(object).find((key) => object[key] === value);
      }
      const updateScatter = async function (
        key,
        svgArr,
        scatterX,
        scatterY,
        icons
      ) {
        // remove the axes and the text that is already on the svg
        svgArr[3].selectAll("g").remove();
        svgArr[3].selectAll("text").remove();

        // add a text item, halfway down the svg, to the left of the x axis
        svgArr[3]
          .append("text")
          .classed("xAxisText", true)
          .attr(
            "transform",
            "translate(" + svgArr[1] / 2 + "," + (svgArr[2] + 35) + " )"
          )
          .attr("text-anchor", "middle")
          .text(d3.select("#xAxisButton").property("value"));

        // add a text item, at the bottom of the svg, underneath the y axis
        svgArr[3]
          .append("text")
          .classed("instruction", true)
          .attr("transform", "translate(-60," + svgArr[2] / 2 + " )")
          .attr("text-anchor", "middle")
          .text(d3.select("#yAxisButton").property("value"));

          // recreate the scales
        let scales = await scatterAxes(
          key,
          scatterX,
          scatterY,
          svgArr[1],
          svgArr[2]
        );
        // draw the axis
        iniAxis(svgArr[2], svgArr[3], scales[0], scales[1]);
        // plot the points on the svg
        drawScatter(
          key,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          scatterX,
          scatterY,
          icons
        );
      };

      const iniIcons = async function () {
        // Icons sourced from
        // https://iconarchive.com/show/english-football-club-icons-by-giannis-zographos.html
        let icons = {
          Arsenal:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Arsenal%20FC.ico",
          "Aston Villa":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Aston%20Villa.ico",
          "Birmingham City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Birmingham%20City.ico",
          Blackburn:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Blackburn%20Rovers.ico",
          Blackpool:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Blackpool%20FC.ico",
          Bolton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Bolton%20Wanderers.ico",
          Bournemouth:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Bournemouth.ico",
          Brighton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Brighton%20%26%20Hove%20Albion.ico",
          Burnley:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Burnley%20FC.ico",
          "Cardiff City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Cardiff%20City.ico",
          Chelsea:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Chelsea%20FC.ico",
          "Crystal Palace":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Crystal%20Palace.ico",
          Everton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Everton%20FC.ico",
          Fulham:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Fulham%20FC.ico",
          Huddersfield:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Huddersfield%20Town.ico",
          "Hull City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Hull%20City.ico",
          "Leeds United":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Leeds%20United.ico",
          "Leicester City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Leicester%20City.ico",
          Liverpool:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Liverpool%20FC.ico",
          "Manchester City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Manchester%20City.ico",
          "Manchester Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Manchester%20United.ico",
          Middlesbrough:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Middlesbrough%20FC.ico",
          "Newcastle Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Newcastle%20United.ico",
          "Norwich City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Norwich%20City.ico",
          QPR: "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Queens%20Park%20Rangers.ico",
          Reading:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Reading%20FC.ico",
          "Sheffield Utd":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Sheffield%20United.ico",
          Southhampton:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Southampton%20FC.ico",
          "Stoke City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Stoke%20City.ico",
          Sunderland:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Sunderland%20AFC.ico",
          "Swansea City":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Swansea%20City.ico",
          Tottenham:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Tottenham%20Hotspur.ico",
          Watford:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Watford%20FC.ico",
          "West Brom":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/West%20Bromwich%20Albion.ico",
          "West Ham":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/West%20Ham%20United.ico",
          "Wigan Athletic":
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Wigan%20Athletic.ico",
          Wolves:
            "https://raw.githubusercontent.com/Nfb4/lab4/master/icons/Wolverhampton%20Wanderers.ico",
        };
        return icons;
      };

      const iniButtons = function (seasonsArr, seasonsArr2) {
        // initilise the buttons for the bar chart
        d3.select("#start")
          .selectAll("myOptions")
          .data(seasonsArr)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
        d3.select("#end")
          .selectAll("myOptions")
          .data(seasonsArr2)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
      };

      const iniButtonsSingle = function (seasonsArr2) {
        // update the second season options based on the start season selected
        d3.select("#end")
          .selectAll("myOptions")
          .data(seasonsArr2)
          .enter()
          .append("option")
          .text(function (d) {
            return d;
          }) // text showed in the menu
          .attr("value", function (d) {
            return d;
          }); // corresponding value returned by the button
      };

      const iniBarChart = async function (
        svgArrBar,
        seasonKey1,
        seasonKey2,
        csvArr,
        totals,
        barsize
      ) {
        // remove the text from the svg
        svgArrBar[3].selectAll("text").remove();

        // add a graph title
        svgArrBar[3]
          .append("text")
          .classed("barTitle", true)
          .attr("transform", "translate(" + svgArrBar[1] / 2 + ", 0)")
          .attr("text-anchor", "middle")
          .text(
            "Premier league spend from " + seasonKey1 + " to " + seasonKey2
          );
        // add text to the bottom of the svg indicating what the x axis is
        svgArrBar[3]
          .append("text")
          .classed("xAxisText", true)
          .attr(
            "transform",
            "translate(" + svgArrBar[1] / 2 + "," + (svgArrBar[2] + 35) + " )"
          )
          .attr("text-anchor", "middle")
          .text("Spend - (£ - Millions)");

        // sleep value is initilised at 0 so the graph is drawn immediately
        let sleepVal = 0;
        // iterate through the csvs and populate the data
        for (let i = 0; i < csvArr.length; i++) {
          // key set to season info from the csv path
          let key = csvArr[i].slice(68, 73);
          // populate the season data for the current season
          await dummyFuncSeason(csvArr[i]);
          // for each team in the current csv file, update the totals 
          // if the club already exists, update the data, if not add the entry
          for (let team in seasons[key]) {
            if (seasons[key][team][0] > 0) {
              if (totals[team] != undefined) {
                totals[team][0] = totals[team][0] + seasons[key][team][0];
              } else {
                totals[team] = [seasons[key][team][0], 0];
              }
            }
            // needs this if as some entries have no income values
            if (seasons[key][team][1] > 0) {
              if (totals[team] != undefined) {
                totals[team][1] = totals[team][1] + seasons[key][team][1];
              } else {
                totals[team][1] = [0, seasons[key][team][1]];
              }
            }
          }
          // wait so that the current state of the graph can be observed
          await sleep(sleepVal);
          // update the sleep value so that the wait occurs, for following updates
          // as a  wait at the very beginning is pointless
          sleepVal = 0;

          await updateBar(totals, key, svgArrBar, barsize);
        }
      };

      const iniBarChartUpdate = async function (
        svgArrBar,
        seasonKey1,
        seasonKey2,
        csvArr,
        barsize
      ) {
        // totals to keep increasing values
        let sleepVal = 1500
        totals = {};
        // set a title for the graph
        svgArrBar[3]
          .select(".barTitle")
          .text(
            "Premier league spend from " + seasonKey1 + " to " + seasonKey2
          );
        // iterate through the csvs and populate the data
        for (let i = 0; i < csvArr.length; i++) {
                    // key set to season info from the csv path

          let key = csvArr[i].slice(68, 73);
          // populate the season data for the current season

          await dummyFuncSeason(csvArr[i]);
                    // for each team in the current csv file, update the totals 
          // if the club already exists, update the data, if not add the entry
          for (let team in seasons[key]) {
            if (seasons[key][team][0] > 0) {
              if (totals[team] != undefined) {
                totals[team][0] = totals[team][0] + seasons[key][team][0];
              } else {
                totals[team] = [seasons[key][team][0], 0];
              }
            }
            // needs this if as some entries have no income values

            if (seasons[key][team][1] > 0) {
              if (totals[team] != undefined) {
                totals[team][1] = totals[team][1] + seasons[key][team][1];
              } else {
                totals[team][1] = [0, seasons[key][team][1]];
              }
            }
          }
          // wait so that the current state of the graph can be observed
          await sleep(sleepVal);
          // update the 
          await updateBar(totals, key, svgArrBar, barsize);
        }
      };

      const radar = function () {
        // intitlise the data, to load an initial radarchart
        let key = "16-17";
        let club = "Liverpool";
        let data = seasons[key][club];

        //Call function to draw the Radar chart
        RadarChart(".radarChart", data, key, club);
      };

      function RadarChart(id, input, season, club) {
        // Based off this template http://bl.ocks.org/tpreusse/2bc99d74a461b8c0acb1
        // clear the svg
        d3.select(id).select("svg").remove();
        // initilse dimensions of the svg
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // Set the features array so the axes can be populated
        let features = [
          "Spend",
          "Income",
          "Net",
          "Wins",
          "Draws",
          "Loses",
          "Goals For",
          "Goals Against",
          "Points",
        ];
        // dictionary set up to store the data
        let data = [{}];
        for (let i = 0; i < features.length; i++) {
          // from the loaded dictionary, add the data items,
          // along with the feature name
          data[0][features[i]] = input[i];
        }
        // find the largest value in the dataset to set the limits of the graph
        let max = 0;
        for (let i = 0; i < features.length; i++) {
          if (data[0][features[i]] > max) {
            max = data[0][features[i]];
          }
        }
        // round the max up to the next 10 so that the graph has some spacing
        max = Math.ceil(max / 10) * 10;

        let svg = d3
          .select(id)
          .append("svg")
          .attr("width", width)
          .attr("height", height);
          // clear the text
        d3.select(id).select("svg").select("text").remove();

        // add title for the chart
        svg
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(" + height / 2 + ", 12)")
          .attr("text-anchor", "middle")
          .text("Radar chart for " + club + " during " + season);

          
        
        // set a scale with the max that has been found
        let radialScale = d3.scaleLinear().domain([0, max]).range([0, 250]);
        // set the breaks in the chart to fifths of the max
        let ticks = [max * 0.2, max * 0.4, max * 0.6, max * 0.8, max];
        ticks.forEach((t) =>
          svg
            .append("circle")
            .attr("cx", 300)
            .attr("cy", 300)
            .attr("fill", "none")
            .attr("stroke", "gray")
            .attr("r", radialScale(t))
        );
        // Add a text above the center for the tick value
        ticks.forEach((t) =>
          svg
            .append("text")
            .attr("x", 305)
            .attr("y", 300 - radialScale(t))
            .text(t.toString())
        );
        function angleToCoordinate(angle, value) {
          let x = Math.cos(angle) * radialScale(value);
          let y = Math.sin(angle) * radialScale(value);
          return { x: 300 + x, y: 300 - y };
        }
        for (var i = 0; i < features.length; i++) {
          let ft_name = features[i];
          let angle = Math.PI / 2 + (2 * Math.PI * i) / features.length;
          let line_coordinate = angleToCoordinate(angle, max);
          let label_coordinate = angleToCoordinate(angle, max + 5);

          //draw axis line
          svg
            .append("line")
            .attr("x1", 300)
            .attr("y1", 300)
            .attr("x2", line_coordinate.x)
            .attr("y2", line_coordinate.y)
            .attr("stroke", "black");

          //draw axis label
          svg
            .append("text")
            .attr("x", label_coordinate.x)
            .attr("y", label_coordinate.y)
            .text(ft_name);
        }
        let line = d3
          .line()
          .x((d) => d.x)
          .y((d) => d.y);
        let colors = ["navy"];
        function getPathCoordinates(data_point) {
          let coordinates = [];
          for (var i = 0; i < features.length; i++) {
            let ft_name = features[i];
            let angle = Math.PI / 2 + (2 * Math.PI * i) / features.length;
            coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
          }
          return coordinates;
        }
        for (var i = 0; i < data.length; i++) {
          let d = data[i];
          let color = colors[i];
          let coordinates = getPathCoordinates(d);

          //draw the path element
          svg
            .append("path")
            .datum(coordinates)
            .attr("d", line)
            .attr("stroke-width", 3)
            .attr("stroke", color)
            .attr("fill", color)
            .attr("stroke-opacity", 1)
            .attr("opacity", 0.5);
        }
      }

      const main = async function (spendPerClubPerSeason, csvArr) {
        // As the axes selected in the scatter graph are in an array, the strings selected
        // need to correspond to the values
        let axisDict = {
          Spend: 0,
          "Incoming Money": 1,
          Wins: 3,
          Draws: 4,
          Loses: 5,
          "Goals For": 6,
          "Goals Against": 7,
          Points: 8,
          Attendance: 9,
        };
        // The possible seasons for the graphs
        const seasonsArr = [
          "10-11",
          "11-12",
          "12-13",
          "13-14",
          "14-15",
          "15-16",
          "16-17",
          "17-18",
          "18-19",
          "19-20",
          "20-21",
        ];
        // The size of the bars in the first bar chart
        let barsize = 10;

        // initilise the dictionary to store cummulative data
        let totals = {};
        // load the icons for the scatter graph
        let icons = await iniIcons();

        // Initial values for the scatter graph
        let seasonKey = "10-11"
        let scatterX = axisDict["Goals For"];
        let scatterY = axisDict["Goals For"];

        // Second select button options for the bar chart, same as initial list less the first index
        let seasonsArr2 = seasonsArr.slice(1);

        iniButtons(seasonsArr, seasonsArr2);

        await dummyFunc(spendPerClubPerSeason);

        let svgArrScatter = await iniSVGScatter(seasonKey, seasonsArr);

        let svgArrBar = await iniSVG();

        await iniBarChart(svgArrBar, "10-11", "20-21", csvArr, totals, barsize);

        await updateScatter(
          seasonKey,
          svgArrScatter,
          scatterX,
          scatterY,
          icons
        );

        // When the time period is changed for the scatter graph update the scatter based on the values in each button
        d3.select("#timePeriod").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select(this).property("value");
          const option2 = d3.select("#xAxisButton").property("value");
          const option3 = d3.select("#yAxisButton").property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });
        
        // When the yAxis period is changed for the scatter graph update the scatter based on the values in each button
        d3.select("#yAxisButton").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select("#timePeriod").property("value");
          const option2 = d3.select("#xAxisButton").property("value");
          const option3 = d3.select(this).property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });
        // When the xAxis period is changed for the scatter graph update the scatter based on the values in each button
        d3.select("#xAxisButton").on("change", function (event, d) {
          // recover the option that has been chosen
          const option1 = d3.select("#timePeriod").property("value");
          const option2 = d3.select(this).property("value");
          const option3 = d3.select("#yAxisButton").property("value");
          updateScatter(
            option1,
            svgArrScatter,
            axisDict[option2],
            axisDict[option3],
            icons
          );
        });

        // When the start season is changed, update the end options so the end cannot be after the start
        d3.select("#start").on("change", function (event, d) {
          // recover the option that has been chosen
          const option = d3.select(this).property("value");

          let index = seasonsArr.findIndex((season) => season === option);

          removeOptions(document.getElementById("end"));
          iniButtonsSingle(seasonsArr.slice(index));
        });
        // when the button is clicked, take the values for start and end seasons
        // find their indexs in the seasons list, then load the bar chart only using the seasons in this range
        // clear the options for the buttons and reset them,to the start
        d3.select("#barButton").on("click", function (event, d) {
          const start = d3.select("#start").property("value");
          const end = d3.select("#end").property("value");
          let indexStart = seasonsArr.findIndex((season) => season === start);
          let indexEnd = seasonsArr.findIndex((season) => season === end);
          iniBarChartUpdate(
            svgArrBar,
            start,
            end,
            csvArr.slice(indexStart, indexEnd + 1),
            barsize
          );
          removeOptions(document.getElementById("start"));
          removeOptions(document.getElementById("end"));
          iniButtons(seasonsArr, seasonsArr.slice(indexEnd));
        });
        // call the circular bar chart
        let svgArrCircular = await iniSVGCircular();
        await updateCircle(totals, svgArrCircular);
        // call the radar chart
        radar();
      };
      function removeOptions(selectElement) {
        var i,
          L = selectElement.options.length - 1;
        for (i = L; i >= 0; i--) {
          selectElement.remove(i);
        }
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      main(spendPerClubPerSeason, csvArr);
    </script>
  </body>
</html>
