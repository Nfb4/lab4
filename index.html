<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <style>
    .tick line {
      visibility: hidden;
    }
  </style>
  <body>
    <!-- <script src="lab4.js"></script> -->

    <script>
      // CSV of spend data, all seasons in one csv
      let spendPerClubPerSeason =
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/spend.csv";

      // multiple csvs of stats for each individual season
      let csvArr = [
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem10-11.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem11-12.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem12-13.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem13-14.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem14-15.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem15-16.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem16-17.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem17-18.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem18-19.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem19-20.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem20-21.csv",
      ];

      // Dictionary to store totals data for each club
      let cumulative = {};

      // Dictionary of dictionaries for each club in each season
      let seasons = {
        "20-21": {},
        "19-20": {},
        "18-19": {},
        "17-18": {},
        "16-17": {},
        "15-16": {},
        "14-15": {},
        "13-14": {},
        "12-13": {},
        "11-12": {},
        "10-11": {},
      };

      const processCsvEntrySpend = async function (csvLine) {
        // do stuff for that single csv
        let entryDict = {};

        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["spend"].slice(csvLine["spend"].length - 3) == "Th.") {
          spend =
            parseFloat(csvLine["spend"].slice(1, csvLine["spend"].length - 3)) *
            0.001;
        }
        // If there is no value set spend to 0
        else if (csvLine["spend"] == "") {
          spend = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          spend = parseFloat(
            csvLine["spend"].slice(1, csvLine["spend"].length - 1)
          );
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["inc"].slice(csvLine["inc"].length - 3) == "Th.") {
          inc =
            parseFloat(csvLine["inc"].slice(1, csvLine["inc"].length - 3)) *
            0.001;
        }
        // If there is no value set inc to 0
        else if (csvLine["inc"] == "") {
          inc = 0;
        }
        // Parse as int and remove '£' and 'M'
        else {
          inc = parseFloat(csvLine["inc"].slice(1, csvLine["inc"].length - 1));
        }
        // If the spend is in the thousands, multiple by .001 so it is inline with the other values in millions
        if (csvLine["net"].slice(csvLine["net"].length - 3) == "Th.") {
          net =
            parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 3)) *
            0.001;
        }
        // If there is no value set net to 0
        else if (csvLine["net"] == "") {
          net = 0;
        } else {
          // Parse as int and remove '£' and 'M'
          net = parseFloat(csvLine["net"].slice(1, csvLine["net"].length - 1));
        }

        entryDict["yr"] = csvLine["yr"];
        entryDict["team"] = csvLine["team"];
        entryDict["spend"] = spend;
        entryDict["inc"] = inc;
        entryDict["net"] = net;

        //return the data from the file
        return entryDict;
      };

      const dummyFunc = async function (csvPath) {
        const csvData = await d3.csv(csvPath);

        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySpend(csvData[i]);
          seasons[clubDict.yr][clubDict.team] = [
            clubDict.spend,
            clubDict.inc,
            clubDict.net,
          ];

          if (cumulative[clubDict.team] != undefined) {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0] + clubDict.spend,
              cumulative[clubDict.team][1] + clubDict.inc,
              cumulative[clubDict.team][0] +
                clubDict.spend -
                (cumulative[clubDict.team][1] + clubDict.inc),
            ];
          } else {
            // If it is undefined simply set the values
            cumulative[clubDict.team] = [
              clubDict.spend,
              clubDict.inc,
              clubDict.net,
            ];
          }
        }
      };

      const processCsvEntrySeason = async function (csvLine) {
        let entryDict = {};
        entryDict["team"] = csvLine["Squad"];

        entryDict["data"] = [
          parseFloat(csvLine["Rk"]),
          parseFloat(csvLine["W"]),
          parseFloat(csvLine["D"]),
          parseFloat(csvLine["L"]),
          parseFloat(csvLine["GF"]),
          parseFloat(csvLine["GA"]),
          parseFloat(csvLine["Pts"]),
        ];
        return entryDict;
      };

      const dummyFuncSeason = async function (csvPath) {
        let key = csvPath.slice(81, 86);
        const csvData = await d3.csv(csvPath);
        for (i = 0; i < csvData.length; i++) {
          let clubDict = await processCsvEntrySeason(csvData[i]);
          seasons[key][clubDict.team] = seasons[key][clubDict.team] = [
            seasons[key][clubDict.team][0],
            seasons[key][clubDict.team][1],
            seasons[key][clubDict.team][2],
            clubDict.data[0],
            clubDict.data[1],
            clubDict.data[2],
            clubDict.data[3],
            clubDict.data[4],
            clubDict.data[5],
            clubDict.data[6],
          ];
          if (cumulative[clubDict.team][3] != undefined) {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0],
              cumulative[clubDict.team][1],
              cumulative[clubDict.team][2],
              cumulative[clubDict.team][3] + clubDict[0],
              cumulative[clubDict.team][4] + clubDict[1],
              cumulative[clubDict.team][5] + clubDict[2],
              cumulative[clubDict.team][6] + clubDict[3],
              cumulative[clubDict.team][7] + clubDict[4],
              cumulative[clubDict.team][8] + clubDict[5],
              cumulative[clubDict.team][2] + clubDict[6],
            ];
          } else {
            cumulative[clubDict.team] = [
              cumulative[clubDict.team][0],
              cumulative[clubDict.team][1],
              cumulative[clubDict.team][2],
              clubDict.data[0],
              clubDict.data[1],
              clubDict.data[2],
              clubDict.data[3],
              clubDict.data[4],
              clubDict.data[5],
              clubDict.data[6],
            ];
          }
        }
      };

      const graphing = async function (totals, width, height) {
        var max = 0;
        for (const key in totals) {
          var clubSpend = totals[key];
          if (clubSpend > max) {
            max = clubSpend;
          }
        }
        var y = d3.scaleBand().domain(Object.keys(totals)).range([0, height]);

        // Define the y scale so that the values are proportionate
        var x = d3.scaleLinear().domain([0, max]).range([0, width]);

        return [x, y];
      };


      const scatterAxes = async function (season, xType, yType, width, height) {
        var maxX = 0;
        var maxY = 0;
        for (const key in seasons[season]) {
          var clubX = seasons[season][key][xType];
          var clubY = seasons[season][key][yType];
          if (clubX > maxX) {
            maxX = clubX;
          }
          if (clubY > maxY) {
            maxY = clubY;
          }
        }
        var y = d3.scaleLinear().domain([0,maxY]).range([height, 0]);

        // Define the y scale so that the values are proportionate
        var x = d3.scaleLinear().domain([0, maxX]).range([0, width]);

        return [x, y];
      };

      // Function used to initilise the x and y axes on start
      const iniAxis = function (height, svg, x, y) {
        // add a bottom x axis to the graph, class it as 'xBot'
        svg
          .append("g")
          .classed("xBot", true)
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add a top x axis to the graph, class it as 'xTop

        // Add a right Y axis class it as 'yLeft'
        svg.append("g").classed("yLeft", true).call(d3.axisLeft(y));
      };

      const iniSVG = async function (season) {
        // set the dimensions and margins of the graph
        const margin = { top: 30, right: 30, bottom: 70, left: 100 };
        const width = 800 - margin.left - margin.right;
        const height = 800 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3
          .select("body")
          .append("div")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + margin.left + "," + margin.top + ")"
          );

        return [margin, width, height, svg];
      };

      const drawBars = function (season, totals, x, y, svg, height, barsize) {
        // Iterate through the dataset and add rectangles for each item
        var mapped = Object.keys(totals).map((d) => {
          return {
            club: d,
            spend: totals[d],
          };
        });
        let adjustment = mapped.length / 4;
        var u = svg.selectAll("rect").data(mapped);

        u.enter()
          .append("rect")
          .attr("x", x(1))
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("height", barsize)
          .merge(u)
          .transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("width", function (d) {
            return x(d.spend);
          })
          .attr("fill", "red");

        u.transition()
          .duration(1000)
          .ease(d3.easeLinear)
          .attr("x", x(1))
          .attr("y", function (d) {
            return y(d.club) + adjustment;
          })
          .attr("width", function (d) {
            return x(d.spend);
          });
      };

      let updateBar = async function (totals, key, svgArr, barsize) {
        svgArr[3].selectAll("g").remove();
        
        let scales = await graphing(totals, svgArr[1], svgArr[2]);

        iniAxis(
          svgArr[2],
          svgArr[3],
          scales[0],
          scales[1]
        );

        drawBars(
          key,
          totals,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          barsize
        );
      };

      const drawScatter = function (season, x, y, svg, height, scatterX, scatterY) {
        // Iterate through the dataset and add rectangles for each item
        var mapped = Object.keys(seasons[season]).map((d) => {
          return {
            club: d,
            xVal: seasons[season][d][scatterX],
            yVal: seasons[season][d][scatterY],
          };
        });

        var u = svg.selectAll("dot").data(mapped);

        u.enter()
          .append("circle")
          .attr("cx", function (d) {
            return x(d.xVal);
          })
          .attr("cy", function (d) {
            return y(d.yVal);
          })
          .attr("r", 5)
          .attr("fill", "red");

        
      };

      let updateScatter = async function (key, svgArr, scatterX, scatterY) {
        svgArr[3].selectAll("g").remove();
        
        let scales = await scatterAxes(key, scatterX, scatterY, svgArr[1], svgArr[2]);
        iniAxis(
          svgArr[2],
          svgArr[3],
          scales[0],
          scales[1]
        );
        drawScatter(
          key,
          scales[0],
          scales[1],
          svgArr[3],
          svgArr[2],
          scatterX,
          scatterY
        );
      };

      const main = async function (spendPerClubPerSeason, csvArr) {
        let barsize = 10;

        let totals = {};

        let seasonKey = csvArr[0].slice(81, 86);
        let scatterX = 7;
        let scatterY = 9;

        await dummyFunc(spendPerClubPerSeason);
        let svgArrBar = await iniSVG(seasonKey);

        svgArrBar[3]
          .append("text")
          .classed("text", true)
          .attr("transform", "translate(" + svgArrBar[1]/2 +", 0)")
          .attr("text-anchor", "middle")
          .text("Premier league spend from 10-11 to " + seasonKey)

        let svgArrScatter = await iniSVG(seasonKey);

        let sleepVal = 0;
        for (let i = 0; i < csvArr.length; i++) {
          let key = csvArr[i].slice(81, 86);

          await dummyFuncSeason(csvArr[i]);
          for (let team in seasons[key]) {
            if (seasons[key][team][0] > 0) {
              if (totals[team] != undefined) {
                totals[team] = totals[team] + seasons[key][team][0];
              } else {
                totals[team] = seasons[key][team][0];
              }
            }
          }
          await sleep(sleepVal);
          sleepVal = 0;
          svgArrBar[3].selectAll("text")
          .text("Premier league spend from 10-11 to " + key)
          await updateBar(totals, key, svgArrBar, barsize);
        }
        await updateScatter(seasonKey, svgArrScatter, scatterX, scatterY)
      };
      
      

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      main(spendPerClubPerSeason, csvArr);
    </script>
  </body>
</html>
